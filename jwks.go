package main

import (
	"crypto/rsa"
	"encoding/base64"
	"encoding/binary"
	"encoding/json"
	"errors"
	"io/ioutil"
	"math/big"
)

const (

	// KeyTypeRSA represents a cryptography key generated by an RSA algorithm.
	KeyTypeRSA = "RSA"
)

var (

	// ErrNotExpectedKeyType indicates that the given public key was not of the expected type.
	ErrNotExpectedKeyType = errors.New("the given public key was not of the expected type")
)

// TODO
type keystore struct {
	Keys []rawKey
}

// TODO
type rawKey struct {
	Exponent string `json:"e"`
	KeyID    string `json:"kid"`
	KeyType  string `json:"kty"`
	Modulus  string `json:"n"`
}

func main() {
	data, err := ioutil.ReadFile("key.json")
	if err != nil {
		panic(err.Error())
	}

	var key rawKey
	if err = json.Unmarshal(data, &key); err != nil {
		panic(err.Error())
	}

	parseRawRSA(key)
}

// TODO
func parseRawRSA(raw rawKey) (publicKey *rsa.PublicKey, err error) {

	// TODO Check for empty strings?

	// Decode the exponent from Base64.
	//
	// According to RFC 7518, this is a Base64 URL unsigned integer.
	// https://tools.ietf.org/html/rfc7518#section-6.3
	var exponent []byte
	if exponent, err = base64.RawURLEncoding.DecodeString(raw.Exponent); err != nil {
		return nil, err
	}

	// Decode the modulus from Base64.
	var modulus []byte
	if modulus, err = base64.RawURLEncoding.DecodeString(raw.Modulus); err != nil {
		return nil, err
	}

	// Create the RSA public key.
	publicKey = &rsa.PublicKey{}

	// Turn the exponent into an integer.
	//
	// According to RFC 7517, these numbers are in big-endian format.
	// https://tools.ietf.org/html/rfc7517#appendix-A.1
	publicKey.E = int(binary.BigEndian.Uint16(exponent)) // TODO Confirm 16 bits.

	// Turn the modulus into a *big.Int.
	publicKey.N = big.NewInt(0).SetBytes(modulus)

	return publicKey, nil
}
